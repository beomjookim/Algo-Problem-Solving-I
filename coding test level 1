https://programmers.co.kr/learn/challenges

<나누어 떨어지는 숫자 배열>,<약수의 합>,<내적>,<자릿수 더하기>,<문자열 다루기 기본>,<문자열 내 p와 y의 개수>
too easy to comment.

<두 개 뽑아서 더하기>
방법 1. 중복을 허용하지 않는 set을 사용하고, 끝에 answer.assign(st.begin(), st.end());로 마무리해준다.
방법 2. 만약 set을 안 쓰고 answer.erase(unique(answer.begin(), answer.end()), answer.end());로 중복을 없애준다.

<2016년>
방법: hard-coding인데, if - else if 시리즈 연발하지 않고 그냥 배열에 다 넣어주면 된다.

<K번째 수>
공간과 시간복잡도 사이의 평형을 찾아라.

<이상한 문자 만들기>
string의 성질을 잊지 말자. string s의 길이는 걍 s.length() 혹은 s.size() 사용.
string상의 i번째 문자를 보려면 s.at(i);을 쓰면 된다.
또한, ASCII CODE 상의 32 차이를 더하거나 빼주는 대신 string library의 toupper, tolower 사용하면 된다.

<두 정수 사이의 합>
swap 함수 활용.

<같은 숫자는 싫어>
굳이 기존 거에서 erase로 지우고 땡겨 올 생각 말고 새 벡터에 넣어주자.

<가운데 글자 가져오기>
주어진 string이 짝수인지 홀수인지 여부는 s.length() & 1을 사용하면 된다.
그리고 s.substr(s.length()*0.5,1) : s.substr(s.length()*0.5-1,2) 이렇게 쓰면 더욱 깔끔!

<서울에서 김서방 찾기>
string library에 있는 to_string을 사용해서 int를 string으로 바꿔준다.

<문자열 내림차순으로 배치하기>
#include <algorithm>을 사용해서 sort, reverse 함수 사용한다.

<자연수 뒤집어 배열로 만들기>
어렵게 생각 말고 simple하게 자연수 뒤에서부터 배열에 넣으며 shrink.

<정수 제곱근 판별>
#include <cmath>를 사용해서 pow, sqrt, floor 함수 사용한다.






<문자열 내 마음대로 정렬하기>
놀라 나자빠질만한 답이다. 나는 처음에 자릿수 char끼리 비교해서 큰 틀에서 정렬해주고 이후에 부분적 정렬을 시도했다.
물론 이 풀이도 나쁘지 않은 풀이지만, C++ STL을 활용할 수 있는 정말 좋은 풀이가 하나 더 있다.
#include <algorithm> 내에 있는 sort 함수를 쓸 때 일반적으로 그냥 v.begin() v.end() 써 주곤 했는데, 뒤에 인자를 하나 더 붙이면
reverse나 부분 비교와 같은 기능을 추가할 수 있다. 그러니까 이 문제의 경우에는, sort(strings.begin(), strings.end(), cmp)자릿수의 비교를 먼저 해주는 기능을 추가할 수 있었다.
* 참고: sort의 iterator는 [,)다. 즉, sort 해주고 싶은 마지막 성분보다 하나 크게 범위를 잡아야 한다는 것이다.

<소수 찾기>
//////////

<제일 작은 수 제거하기>
/////

<최대공약수와 최소공배수>
a와 b의 최대공약수를 구할 때, 유클리드 호제법을 사용한다.
a <= b라는 전제 하에, int k를 만들어서
while(m != 0)
{
    k = n % m;
    n = m;
    m = k;
}
해주면 n이 최대공약수다.

n9
m12
k

<행렬의 덧셈>
2D 벡터를 땡겨올 때 각 행마다 새로운 1차원 벡터를 만들어서 입력을 받아준 후 그걸 통째로 복붙해야 한다는 점 명심!

<하샤드 수>
이 방법이 꼭 필요하지는 않지만, char를 int로 변환할 때, c - '0';를 사용해준다.

<문자열을 정수로 바꾸기>
#include <string>에 있는 stoi()함수를 활용한다.












