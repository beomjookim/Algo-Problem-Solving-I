<나누어 떨어지는 숫자 배열>,<약수의 합>,<내적>
too easy to comment.

<두 개 뽑아서 더하기>
방법 1. 중복을 허용하지 않는 set을 사용하고, 끝에 answer.assign(st.begin(), st.end());로 마무리해준다.
방법 2. 만약 set을 안 쓰고 answer.erase(unique(answer.begin(), answer.end()), answer.end());로 중복을 없애준다.

<2016년>
방법: hard-coding인데, if - else if 시리즈 연발하지 않고 그냥 배열에 다 넣어주면 된다.

<K번째 수>
공간과 시간복잡도 사이의 평형을 찾아라.

<이상한 문자 만들기>
string의 성질을 잊지 말자. string s의 길이는 걍 s.length() 혹은 s.size() 사용.
string상의 i번째 문자를 보려면 s.at(i);을 쓰면 된다.
또한, ASCII CODE 상의 32 차이를 더하거나 빼주는 대신 string library의 toupper, tolower 사용하면 된다.

<두 정수 사이의 합>
//

<소수 찾기>
//////////

<자연수 뒤집어 배열로 만들기>
///

<가운데 글자 가져오기>
주어진 string이 짝수인지 홀수인지 여부는 s.length() & 1을 사용하면 된다.
그리고 s.substr(s.length()*0.5,1) : s.substr(s.length()*0.5-1,2) 이렇게 쓰면 더욱 깔끔!

<서울에서 김서방 찾기>
string library에 있는 to_string을 사용해서 int를 string으로 바꿔준다.

<최대공약수와 최소공배수>
a와 b의 최대공약수를 구할 때, 유클리드 호제법을 사용한다.
a <= b라는 전제 하에, int k를 만들어서
while(m != 0)
{
    k = n % m;
    n = m;
    m = k;
}
해주면 n이 최대공약수다.

n9
m12
k



<>
