## 나의 풀이

오랜만에 DFS로 풀어보려고 했는데, 정확도는 나왔지만 파이썬이라 그런지 시간초과가 났다.  
global은 쓰는 함수마다 새로 써줘야 하고(상위 함수에 정의되어 있어도 추가로 해줘야 함), 몸통은 solution 내부가 아닌 전역에 있어야 한다.  

```python
# 시간 초과 풀이 DFS
from copy import deepcopy

res = float('inf')

def solution(board):
    global res
    n = len(board)
    
    def recursion(prev_dir, cur_pos, cur_cost, temp_board):
        global res
        direction = [[-1,0], [0,-1], [1,0], [0,1]]
        
        if cur_pos == [n-1, n-1]:
            if cur_cost < res: res = cur_cost
            return
        
        def in_range(a, b):
            if 0 > a or a > n-1 or 0 > b or b > n-1: return False
            return True
        
        for dx, dy in direction:
            tx, ty = cur_pos[0]+dx, cur_pos[1]+dy
            if in_range(tx, ty) and not temp_board[tx][ty]:
                t_cost, t_board = deepcopy(cur_cost), deepcopy(temp_board)
                if prev_dir and prev_dir != [dx,dy]: t_cost += 500
                t_cost += 100
                if t_cost < res:
                    t_board[tx][ty] = 2
                    recursion([dx,dy], [tx,ty], t_cost, t_board)
        
    recursion([], [0,0], 0, board)
    return res
```

최단거리가 아닌 것처럼 보였는데 다시 생각해보니 최단거리일 수 있겠다는 생각이 든다. BFS로 풀어보자.  
